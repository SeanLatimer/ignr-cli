//go:build integration

package templates

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestTemplateWorkflowIntegration(t *testing.T) {
	tmpDir := t.TempDir()
	cachePath := filepath.Join(tmpDir, "cache", "github-gitignore")
	
	// Setup: Create template files
	if err := os.MkdirAll(cachePath, 0o755); err != nil {
		t.Fatalf("failed to create cache path: %v", err)
	}
	
	templates := map[string]string{
		"Go.gitignore":     "# Go\n*.exe\nvendor/",
		"Python.gitignore": "# Python\n*.pyc\n__pycache__/",
	}
	
	for name, content := range templates {
		path := filepath.Join(cachePath, name)
		if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
			t.Fatalf("failed to create template file: %v", err)
		}
	}
	
	// Step 1: Discover templates
	discovered, err := DiscoverTemplates(cachePath)
	if err != nil {
		t.Fatalf("DiscoverTemplates() error = %v", err)
	}
	
	if len(discovered) != len(templates) {
		t.Fatalf("DiscoverTemplates() = %d templates, want %d", len(discovered), len(templates))
	}
	
	// Build index to find specific templates
	index := BuildIndex(discovered)
	
	var selected []Template
	for _, name := range []string{"Go", "Python"} {
		tmpl, found := FindTemplate(index, name)
		if !found {
			t.Fatalf("FindTemplate(%q) not found", name)
		}
		selected = append(selected, tmpl)
	}
	
	// Step 2: Load templates
	loaded, err := LoadTemplates(selected)
	if err != nil {
		t.Fatalf("LoadTemplates() error = %v", err)
	}
	
	if len(loaded) != len(selected) {
		t.Fatalf("LoadTemplates() = %d loaded templates, want %d", len(loaded), len(selected))
	}
	
	// Verify content
	for _, lt := range loaded {
		if lt.Content == "" {
			t.Errorf("LoadTemplates() template %q content is empty", lt.Template.Name)
		}
		if !strings.Contains(lt.Content, lt.Template.Name) {
			t.Errorf("LoadTemplates() template %q content does not contain template name", lt.Template.Name)
		}
	}
	
	// Step 3: Merge templates
	merged := MergeTemplates(loaded, MergeOptions{
		Deduplicate: true,
		AddHeader:   true,
		Generator:   "ignr",
		Version:     "test",
		Timestamp:   time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
	})
	
	if merged == "" {
		t.Error("MergeTemplates() returned empty string")
	}
	
	// Verify header
	if !strings.Contains(merged, "Generated by ignr test") {
		t.Error("MergeTemplates() header missing generator info")
	}
	if !strings.Contains(merged, "Templates: Go, Python") {
		t.Error("MergeTemplates() header missing template names")
	}
	
	// Verify template sections
	if !strings.Contains(merged, "# --- Go ---") {
		t.Error("MergeTemplates() missing Go template section")
	}
	if !strings.Contains(merged, "# --- Python ---") {
		t.Error("MergeTemplates() missing Python template section")
	}
	
	// Verify content
	if !strings.Contains(merged, "*.exe") {
		t.Error("MergeTemplates() missing Go template content")
	}
	if !strings.Contains(merged, "*.pyc") {
		t.Error("MergeTemplates() missing Python template content")
	}
	
	// Step 4: Verify output format
	lines := strings.Split(merged, "\n")
	if len(lines) < 5 {
		t.Errorf("MergeTemplates() output has %d lines, want at least 5", len(lines))
	}
	
	// Verify deduplication (if any duplicate lines existed, they should be removed)
	lineCounts := make(map[string]int)
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			lineCounts[line]++
		}
	}
	
	// Check for duplicates (excluding comment lines and section headers)
	for line, count := range lineCounts {
		if !strings.HasPrefix(line, "#") && count > 1 {
			t.Errorf("MergeTemplates() duplicate line found: %q (count: %d)", line, count)
		}
	}
}

func TestTemplateWorkflowWithDeduplication(t *testing.T) {
	tmpDir := t.TempDir()
	cachePath := filepath.Join(tmpDir, "cache", "github-gitignore")
	
	if err := os.MkdirAll(cachePath, 0o755); err != nil {
		t.Fatalf("failed to create cache path: %v", err)
	}
	
	// Create templates with duplicate lines
	templates := map[string]string{
		"Go.gitignore":     "# Go\n*.exe\nvendor/\n*.log",
		"Python.gitignore": "# Python\n*.pyc\n*.log",
	}
	
	for name, content := range templates {
		path := filepath.Join(cachePath, name)
		if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
			t.Fatalf("failed to create template file: %v", err)
		}
	}
	
	// Discover and load
	discovered, err := DiscoverTemplates(cachePath)
	if err != nil {
		t.Fatalf("DiscoverTemplates() error = %v", err)
	}
	
	index := BuildIndex(discovered)
	var selected []Template
	for _, name := range []string{"Go", "Python"} {
		tmpl, _ := FindTemplate(index, name)
		selected = append(selected, tmpl)
	}
	
	loaded, err := LoadTemplates(selected)
	if err != nil {
		t.Fatalf("LoadTemplates() error = %v", err)
	}
	
	// Merge with deduplication
	merged := MergeTemplates(loaded, MergeOptions{
		Deduplicate: true,
		AddHeader:   false,
	})
	
	// Count occurrences of "*.log"
	count := strings.Count(merged, "*.log")
	if count != 1 {
		t.Errorf("MergeTemplates() with deduplication: *.log appears %d times, want 1", count)
	}
	
	// Merge without deduplication
	mergedNoDedup := MergeTemplates(loaded, MergeOptions{
		Deduplicate: false,
		AddHeader:   false,
	})
	
	// Count occurrences of "*.log" (should be 2)
	countNoDedup := strings.Count(mergedNoDedup, "*.log")
	if countNoDedup != 2 {
		t.Errorf("MergeTemplates() without deduplication: *.log appears %d times, want 2", countNoDedup)
	}
}
