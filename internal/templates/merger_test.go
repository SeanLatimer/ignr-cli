package templates

import (
	"strings"
	"testing"
	"time"
)

func TestMergeTemplates(t *testing.T) {
	tests := []struct {
		name     string
		loaded   []LoadedTemplate
		opts     MergeOptions
		expected interface{} // string or func(string) bool
	}{
		{
			name: "single template",
			loaded: []LoadedTemplate{
				{
					Template: Template{Name: "Go"},
					Content:  "# Go\ngo.mod",
				},
			},
			opts: MergeOptions{
				Deduplicate: false,
				AddHeader:   false,
			},
			expected: "# --- Go ---\n# Go\ngo.mod\n",
		},
		{
			name: "multiple templates",
			loaded: []LoadedTemplate{
				{
					Template: Template{Name: "Go"},
					Content:  "# Go\ngo.mod",
				},
				{
					Template: Template{Name: "Python"},
					Content:  "# Python\n*.pyc",
				},
			},
			opts: MergeOptions{
				Deduplicate: false,
				AddHeader:   false,
			},
			expected: "# --- Go ---\n# Go\ngo.mod\n\n\n# --- Python ---\n# Python\n*.pyc\n",
		},
		{
			name: "with header",
			loaded: []LoadedTemplate{
				{
					Template: Template{Name: "Go"},
					Content:  "# Go\ngo.mod",
				},
			},
			opts: MergeOptions{
				Deduplicate: false,
				AddHeader:   true,
				Generator:   "ignr",
				Version:     "1.0.0",
				Timestamp:   time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			},
			expected: func(s string) bool {
				return strings.Contains(s, "Generated by ignr 1.0.0") &&
					strings.Contains(s, "Templates: Go") &&
					strings.Contains(s, "# --- Go ---")
			},
		},
		{
			name:     "empty templates",
			loaded:   []LoadedTemplate{},
			opts:     MergeOptions{Deduplicate: false, AddHeader: false},
			expected: "",
		},
		{
			name: "with deduplication",
			loaded: []LoadedTemplate{
				{
					Template: Template{Name: "Go"},
					Content:  "# Go\ngo.mod\nvendor/\n",
				},
				{
					Template: Template{Name: "Python"},
					Content:  "# Python\n*.pyc\nvendor/\n",
				},
			},
			opts: MergeOptions{
				Deduplicate: true,
				AddHeader:   false,
			},
			expected: func(s string) bool {
				// Should have deduplicated vendor/ line
				count := strings.Count(s, "vendor/")
				return count == 1
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := MergeTemplates(tt.loaded, tt.opts)

			switch expected := tt.expected.(type) {
			case string:
				if result != expected {
					t.Errorf("MergeTemplates() = %q, want %q", result, expected)
				}
			case func(string) bool:
				if !expected(result) {
					t.Errorf("MergeTemplates() = %q, did not match expected condition", result)
				}
			}
		})
	}
}

func TestDeduplicateLines(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "no duplicates",
			input:    "line1\nline2\nline3",
			expected: "line1\nline2\nline3",
		},
		{
			name:     "with duplicates",
			input:    "line1\nline2\nline1\nline3",
			expected: "line1\nline2\nline3",
		},
		{
			name:     "all duplicates",
			input:    "line1\nline1\nline1",
			expected: "line1",
		},
		{
			name:     "empty string",
			input:    "",
			expected: "",
		},
		{
			name:     "empty lines",
			input:    "line1\n\nline2\n\n",
			expected: "line1\n\nline2",
		},
		{
			name:     "preserves order",
			input:    "z\na\nb\nz\na",
			expected: "z\na\nb",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := DeduplicateLines(tt.input)
			if result != tt.expected {
				t.Errorf("DeduplicateLines() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestBuildHeader(t *testing.T) {
	tests := []struct {
		name      string
		loaded    []LoadedTemplate
		generator string
		version   string
		timestamp time.Time
		check     func(string) bool
	}{
		{
			name: "basic header",
			loaded: []LoadedTemplate{
				{Template: Template{Name: "Go"}},
				{Template: Template{Name: "Python"}},
			},
			generator: "ignr",
			version:   "1.0.0",
			timestamp: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			check: func(s string) bool {
				return strings.Contains(s, "Generated by ignr 1.0.0") &&
					strings.Contains(s, "Templates: Go, Python") &&
					strings.Contains(s, "Timestamp: 2024-01-01T00:00:00Z")
			},
		},
		{
			name:      "no version",
			loaded:    []LoadedTemplate{{Template: Template{Name: "Go"}}},
			generator: "ignr",
			version:   "",
			timestamp: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			check: func(s string) bool {
				return strings.Contains(s, "Generated by ignr") &&
					!strings.Contains(s, "Generated by ignr ") &&
					strings.Contains(s, "Templates: Go")
			},
		},
		{
			name:      "zero timestamp uses now",
			loaded:    []LoadedTemplate{{Template: Template{Name: "Go"}}},
			generator: "ignr",
			version:   "1.0.0",
			timestamp: time.Time{},
			check: func(s string) bool {
				return strings.Contains(s, "Generated by ignr 1.0.0") &&
					strings.Contains(s, "Timestamp:")
			},
		},
		{
			name:      "empty templates",
			loaded:    []LoadedTemplate{},
			generator: "ignr",
			version:   "1.0.0",
			timestamp: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			check: func(s string) bool {
				return strings.Contains(s, "Templates: ")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := BuildHeader(tt.loaded, tt.generator, tt.version, tt.timestamp)
			if !tt.check(result) {
				t.Errorf("BuildHeader() = %q, did not match expected condition", result)
			}
		})
	}
}
